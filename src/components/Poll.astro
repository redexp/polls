---
import {render} from "astro:content";
import {basename} from 'node:path';
import type {Poll} from '../lib/polls';
import '../styles/poll.less';

interface Props {
	poll: Poll,
	extractTitle?: boolean,
}

const {poll, extractTitle} = Astro.props;
const {Content, headings} = await render(poll);
const active = !poll.data.expire || poll.data.expire > new Date();
const json = {
	public: poll.data.public,
	expire: poll.data.expire,
};
---

{!!(extractTitle && headings.length > 0) &&
<h2 class="display-5 text-center my-5">{headings[0].text}</h2>}

<form
	id={basename(poll.id)}
	class="poll card shadow-soft p-3 mt-5"
	class:list={{
		titleless: extractTitle,
		disabled: !active,
		public: !!poll.data.public,
	}}
>
    <script type="text/json" set:html={JSON.stringify(json)}> </script>

	<p class="d-flex gap-1">
		<span
			class="badge"
			class:list={{
				"text-bg-success": active,
				"text-bg-secondary": !active,
			}}
		>{active ? 'Активне' : 'Завершилось'}</span>

		<span
			class="badge"
			class:list={{
				"text-bg-success": poll.data.public,
				"text-bg-secondary": !poll.data.public,
			}}
		>{poll.data.public ? 'Публічне' : 'Анонімне'}</span>
	</p>

    <Content/>

	{active &&
	<div class="toolbar">
        <button type="submit" class="btn btn-primary">Надіслати відповіді</button>
    </div>}
</form>

<script>
	import {qsAll} from '../lib/dom';
	import answerConfirm, {
		createSuccessText,
		getPollData,
		sendAnswer,
		tryRestorePendingAnswer
	} from '../lib/answerConfirm';
	import {getAuthParams, retrieveJwt} from "../lib/auth";
	import {showInfoModal} from "../lib/modal";
	import * as notify from '../lib/notify';

	for (const form of qsAll<HTMLFormElement>('form')) {
		form.addEventListener('submit', onSubmit);
		form.addEventListener('change', onChange);

		const data = getPollData(form);

		form.classList.toggle('public', !!data.public);
		form.classList.toggle('disabled', !!data.expire && data.expire.valueOf() < Date.now());
	}

	;(async () => {
		const {auth_token, state} = getAuthParams();

		if (auth_token) {
			await retrieveJwt(auth_token);
		}

		if (!state) return;

		const form = await tryRestorePendingAnswer(state);

		if (!form) return;

		const info = showInfoModal(createSuccessText(form), {size: 'default', html: true});

		info.loading(sendAnswer(form));
	})()
	.catch(err => console.error(err));

	async function onSubmit(e: Event) {
		e.preventDefault();

		const form = e.target as HTMLFormElement;

		const confirmed = await answerConfirm(form);

		if (confirmed) {
			notify.success(createSuccessText(form), {html: true, timeout: 10_000});
		}
		else {
			notify.success('Дякуємо за увагу! Сподіваємося, Вас зацікавлять наступні опитування!');
		}
	}

	function onChange(e: Event) {
		const input = e.target as HTMLInputElement;

		if (input.checked && input.classList.contains('is-invalid')) {
			for (const inp of qsAll(`input[data-group="${input.dataset.group}"]`)) {
				inp.classList.remove('is-invalid');
			}
		}
	}
</script>